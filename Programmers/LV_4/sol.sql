# 특정 기간동안 대여 가능한 자동차들의 대여비용 구하기
-- 자동차 종류가 '세단' 또는 'SUV'
-- 2022년 11월 동안 대여 가능
-- 30일간의 대여 금액이 50만원 이상 200만원 미만
-- 출력 : 자동차 ID, 자동차 종류, 대여 금액(컬럼명: FEE)
-- 대여 금액을 기준으로 내림차순 , 자동차 종류를 기준으로 오름차순, 자동차 ID를 기준으로 내림차순
SELECT DISTINCT C.CAR_ID, C.CAR_TYPE, ROUND(DAILY_FEE * 30*(1-DISCOUNT_RATE/100)) FEE
FROM CAR_RENTAL_COMPANY_CAR C JOIN ( SELECT * FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN
                                WHERE DURATION_TYPE = '30일 이상') P
ON C.CAR_TYPE = P.CAR_TYPE
LEFT JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY H ON C.CAR_ID = H.CAR_ID
WHERE C.CAR_TYPE IN ('세단','SUV')
AND C.CAR_ID NOT IN (SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY WHERE START_DATE <= '2022-11-01' AND END_DATE >= '2022-11-01')
AND ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30) >= 500000 
AND ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30 < 2000000)
ORDER BY FEE DESC, C.CAR_TYPE ASC, C.CAR_ID DESC

-- <핵심>
-- INNER JOIN 과 LEFT JOIN 동시 사용
-- 기간설정 : START_DATE <= '2022-11-01' AND END_DATE >= '2022-11-01'
-- 계산식 : ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30)


-- 저자 별 카테고리 별 매출액 집계하기
SELECT A.AUTHOR_ID, A.AUTHOR_NAME, B.CATEGORY, SUM(SALES * PRICE) TOTAL_SALES
FROM BOOK B JOIN (SELECT *
                  FROM BOOK_SALES
                  WHERE DATE_FORMAT(SALES_DATE,'%Y-%m') = '2022-01') S 
            ON B.BOOK_ID = S.BOOK_ID 
            JOIN AUTHOR A ON B.AUTHOR_ID = A.AUTHOR_ID
GROUP BY A.AUTHOR_ID, CATEGORY
ORDER BY AUTHOR_ID, CATEGORY DESC

SELECT  A.AUTHOR_ID, 
        A.AUTHOR_NAME,
        B.CATEGORY,
        SUM(SALES * PRICE) AS TOTAL_SALES
FROM BOOK_SALES BS
JOIN BOOK B ON B.BOOK_ID = BS.BOOK_ID
JOIN AUTHOR A ON A.AUTHOR_ID = B.AUTHOR_ID
WHERE DATE_FORMAT(BS.SALES_DATE,'%Y-%m') = '2022-01'
GROUP BY A.AUTHOR_ID, B.CATEGORY
ORDER BY A.AUTHOR_ID ASC, B.CATEGORY DESC;

-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기(너무너무너무너무 어려움)
SELECT MONTH(START_DATE) AS MONTH, CAR_ID, COUNT(*) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE CAR_ID IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) BETWEEN 8 AND 10
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
)
AND MONTH(START_DATE) BETWEEN 8 AND 10
GROUP BY MONTH, CAR_ID
ORDER BY MONTH, CAR_ID DESC;

SELECT MONTH(r1.START_DATE) AS Month, r1.CAR_ID, COUNT(*) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY r1
JOIN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) BETWEEN 8 AND 10
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
) AS subq
ON r1.CAR_ID = subq.CAR_ID
WHERE MONTH(r1.START_DATE) BETWEEN 8 AND 10
GROUP BY Month, r1.CAR_ID
ORDER BY Month, r1.CAR_ID DESC;

-- 자동차 대여 기록 별 대여 금액 구하기 (레전드 문제....)
-- 중요!! ROUND(DATEDIFF(END_DATE,START_DATE)+1 * DAILY_FEE) 하면 이상하게 계산됨!!
SELECT HISTORY_ID, CASE
              WHEN plan_id IS NULL THEN ROUND((DATEDIFF(END_DATE,START_DATE)+1) * DAILY_FEE)   -- WHEN plan_id IS NULL THEN ROUND(RENTAL_DATE * DAILY_FEE)
              ELSE ROUND(DAILY_FEE * (DATEDIFF(END_DATE,START_DATE)+1) *(1-DISCOUNT_RATE/100)) -- ELSE ROUND(DAILY_FEE * RENTAL_DATE*(1-DISCOUNT_RATE/100))
          END FEE
FROM
    (SELECT *,  -- DATEDIFF(END_DATE,START_DATE)+1 RENTAL_DATE,
    CASE
        WHEN DATEDIFF(END_DATE,START_DATE)+1 BETWEEN 7 AND 29 THEN '7일 이상'
        WHEN DATEDIFF(END_DATE,START_DATE)+1 BETWEEN 30 AND 79 THEN '30일 이상'
        WHEN DATEDIFF(END_DATE,START_DATE)+1 >= 90 THEN '90일 이상'
    ELSE DATEDIFF(END_DATE,START_DATE)+1
    END DURATION_TYPE
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY)CH JOIN CAR_RENTAL_COMPANY_CAR CC ON CH.CAR_ID = CC.CAR_ID
    LEFT JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN CP ON CC.CAR_TYPE = CP.CAR_TYPE AND CH.DURATION_TYPE = CP.DURATION_TYPE
WHERE CC.CAR_TYPE = '트럭'
GROUP BY CH.HISTORY_ID
ORDER BY FEE DESC, HISTORY_ID DESC

-- 주문량이 많은 아이스크림들 조회하기 
SELECT FH.FLAVOR
FROM FIRST_HALF FH, JULY J
WHERE FH.FLAVOR = J.FLAVOR
GROUP BY FH.FLAVOR
ORDER BY SUM(FH.TOTAL_ORDER) + SUM(J.TOTAL_ORDER) DESC LIMIT 3

-- 취소되지 않은 진료 예약 조회하기
SELECT A.APNT_NO,P.PT_NAME,A.PT_NO,A.MCDP_CD,D.DR_NAME,A.APNT_YMD
FROM APPOINTMENT A, PATIENT P, DOCTOR D
WHERE A.PT_NO = P.PT_NO AND DATE_FORMAT(A.APNT_YMD,'%Y-%m-%d') = '2022-04-13' AND A.MDDR_ID = D.DR_ID AND APNT_CNCL_YN = 'N' AND A.MCDP_CD = 'CS'
ORDER BY A.APNT_YMD

-- 오프라인/온라인 판매 데이터 통합하기
SELECT DATE_FORMAT(SALES_DATE,'%Y-%m-%d') SALES_DATE, PRODUCT_ID, USER_ID, SALES_AMOUNT
FROM ONLINE_SALE
WHERE DATE_FORMAT(SALES_DATE,'%Y-%m') = '2022-03'
UNION ALL
SELECT DATE_FORMAT(SALES_DATE,'%Y-%m-%d') SALES_DATE, PRODUCT_ID, NULL USER_ID, SALES_AMOUNT
FROM OFFLINE_SALE
WHERE DATE_FORMAT(SALES_DATE,'%Y-%m') = '2022-03'
ORDER BY SALES_DATE, PRODUCT_ID, USER_ID

-- 년, 월, 성별 별 상품 구매 회원 수 구하기(DISTINCT ...)
SELECT YEAR(OS.SALES_DATE) YEAR, MONTH(OS.SALES_DATE) MONTH, UI.GENDER ,COUNT(DISTINCT UI.USER_ID) USERS
FROM ONLINE_SALE OS JOIN USER_INFO UI ON UI.USER_ID = OS.USER_ID 
WHERE GENDER IS NOT NULL
GROUP BY YEAR, MONTH, GENDER
ORDER BY YEAR, MONTH, GENDER

-- 그룹별 조건에 맞는 식당 목록 출력하기 (굳이 굳이 MAX를 쓰지 않아도됨.)
SELECT M.MEMBER_NAME,R.REVIEW_TEXT,DATE_FORMAT(R.REVIEW_DATE,'%Y-%m-%d')REVIEW_DATE
FROM MEMBER_PROFILE M, REST_REVIEW R
WHERE M.MEMBER_ID = R.MEMBER_ID AND R.MEMBER_ID = (SELECT MEMBER_ID FROM REST_REVIEW GROUP BY MEMBER_ID ORDER BY COUNT(*) DESC LIMIT 1 )
ORDER BY REVIEW_DATE, REVIEW_TEXT
