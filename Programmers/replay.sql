# SELECT 문제 풀이

-- 3월에 태어난 여성 회원 목록
-- 조건 : 생일 = 3월, 성별 = w, 전화번호 =! NULL

SELECT MEMBER_ID, MEMBER_NAME, GENDER, DATE_FORMAT(DATE_OF_BIRTH,"%Y-%m-%d") DATE_OF_BIRTH
FROM MEMBER_PROFILE
WHERE TLNO IS NOT NULL AND DATE_FORMAT(DATE_OF_BIRTH,"%m") ='03' AND GENDER = "W"
ORDER BY MEMBER_ID

DATE_FORMAT(____,'%Y-%m-%d'), IS NOT NULL

-- 재구매가 일어난 상품과 회원 리스트 구하기
-- 조건 : '동일한 회원'이 '동일한 상품' 재구매 -> COUNT(*) >= 2
-- 정렬 : 회원ID 오름차순 -> 상품ID 내림차순
SELECT USER_ID, PRODUCT_ID
FROM ONLINE_SALE
GROUP BY USER_ID, PRODUCT_ID
HAVING COUNT(*) >= 2
ORDER BY USER_ID, PRODUCT_ID DESC

-- 오프라인/온라인 판매 데이터 통합하기
-- 조건/정렬
-- 2022년 3월의 오프라인/온라인 상품 판매
-- OFFLINE_SALE 테이블의 판매 데이터의 USER_ID 값은 NULL
-- 판매일 오름차순 -> 상품ID 오름차순 -> 유저ID 오름차순
--> INNER, LEFT JOIN 아님 UNION ALL 로 써야함.
SELECT DATE_FORMAT(SALES_DATE,"%Y-%m-%d") SALES_DATE,PRODUCT_ID,USER_ID,SALES_AMOUNT FROM ONLINE_SALE WHERE DATE_FORMAT(SALES_DATE,"%Y-%m") = "2022-03"
UNION ALL
SELECT DATE_FORMAT(SALES_DATE,"%Y-%m-%d") SALES_DATE,PRODUCT_ID,NULL USER_ID,SALES_AMOUNT FROM OFFLINE_SALE WHERE DATE_FORMAT(SALES_DATE,"%Y-%m") = "2022-03"
ORDER BY SALES_DATE,PRODUCT_ID,USER_ID

-- 아픈 동물 찾기
-- 조건, 정렬: = Sick, 아이디순 오름차순
SELECT ANIMAL_ID,NAME
FROM ANIMAL_INS
WHERE INTAKE_CONDITION = "Sick"
ORDER BY ANIMAL_ID

-- 어린 동물 찾기
-- 조건, 정렬: != 'Aged', 아이디순 오름차순
SELECT ANIMAL_ID,NAME
FROM ANIMAL_INS
WHERE INTAKE_CONDITION != 'Aged'
-- WHERE NOT INTAKE_CONDITION LIKE 'AGED'
ORDER BY ANIMAL_ID

-- 동물의 아이디와 이름
-- 조건, 정렬: 모든 동물, ANIMAL_ID 오름차순
SELECT ANIMAL_ID,NAME
FROM ANIMAL_INS
ORDER BY ANIMAL_ID

-- 여러 기준으로 정렬하기
-- 조건, 정렬: 모든 동물, NAME 오름차순, 보호를 나중에 시작
SELECT ANIMAL_ID,NAME,DATETIME
FROM ANIMAL_INS
ORDER BY NAME, DATETIME DESC

-- 상위 N개 레코드
-- 조건: 가장 먼저 들어온 동물의 이름
SELECT NAME
FROM ANIMAL_INS
ORDER BY DATETIME LIMIT 1

-- 조건에 맞는 회원수 구하기
-- 조건: 2021년에 가입, 회원나이 20이상 29이하
SELECT COUNT(*) USERS
FROM USER_INFO
WHERE LEFT(JOINED,4) = '2021' AND AGE >= 20 AND AGE <= 29
-- WHERE DATE_FORMAT(JOINED,'%Y') = '2021' AND AGE BETWEEN 20 AND 29

-- 가장 큰 물고기 10마리 구하기
SELECT ID,LENGTH
FROM FISH_INFO
ORDER BY LENGTH DESC, ID LIMIT 10

-- 잔챙이 갑은 수 구하기
-- 조건: 길이가 10cm 이하 = LENGTH 가 NULL 
SELECT COUNT(*) FISH_COUNT
FROM FISH_INFO
WHERE LENGTH IS NULL

-- Python 개발자 찾기
-- 조건, 정렬: Python 스킬을 가짐, ID 오름차순
SELECT ID, EMAIL, FIRST_NAME, LAST_NAME
FROM DEVELOPER_INFOS
WHERE SKILL_1 = 'Python' OR SKILL_2 = 'Python' OR SKILL_3 = 'Python'
ORDER BY ID

-- 조건에 맞는 개발자 찾기
SELECT ID, EMAIL,FIRST_NAME, LAST_NAME
FROM DEVELOPERS
WHERE SKILL_CODE & (SELECT sum(CODE)
                    FROM SKILLCODES
                    WHERE NAME = 'Python' OR NAME = 'C#')
                    -- WHERE NAME IN ('Python','C#'))
ORDER BY ID
# 비트 단위 논리 연산자 (2진법)
& : 비트 단위 AND
| : 비트 단위 OR
SELECT 1&0; //0으로 출력 
SELECT 1&1; //1로 출력 
SELECT 5&7; //5로 출력(101&111=101) 
SELECT 1|1; //1로 출력 
SELECT 1|0; //1로 출력 
SELECT 5|7; // 7로 출력 (101|111=111)

-- 특정 물고기를 잡은 총 수 구하기
-- 조건: 물고기 이름은 BASS, SNAPPER
SELECT COUNT(*) FISH_COUNT
FROM FISH_INFO
WHERE FISH_TYPE IN (SELECT FISH_TYPE
                    FROM FISH_NAME_INFO
                    WHERE FISH_NAME IN ('BASS','SNAPPER'))

# SUM, MAX, MIN 
-- 가장 비싼 상품 구하기
SELECT MAX(PRICE) MAX_PRICE
FROM PRODUCT

-- 가격이 가장 비싼 식품의 정보 출력하기
SELECT *
FROM FOOD_PRODUCT
WHERE PRICE IN (SELECT MAX(PRICE) FROM FOOD_PRODUCT)

-- 최댓값 구하기
SELECT DATETIME '시간'
FROM ANIMAL_INS
ORDER BY DATETIME DESC LIMIT 1

-- 최솟값 구하기
SELECT DATETIME '시간'
FROM ANIMAL_INS
ORDER BY DATETIME LIMIT 1

-- 동물 수 구하기
SELECT COUNT(*)
FROM ANIMAL_INS

-- 중복 제거하기
-- 조건: 이름이 NULL인 경우는 집계하지 않으며, 중복되는 이름 제거
SELECT COUNT(DISTINCT NAME)
FROM ANIMAL_INS
WHERE NAME IS NOT NULL

-- 조건에 맞는 아이템들의 가격의 총합 구하기
SELECT SUM(PRICE) TOTAL_PRICE
FROM ITEM_INFO
WHERE RARITY = 'LEGEND'

-- 잡은 물고기 중 가장 큰 물고기의 길이 구하기
SELECT CONCAT(MAX(LENGTH),'cm') MAX_LENGTH
FROM FISH_INFO

-- 물고기 종류 별 대어 찾기
SELECT A.ID, B.FISH_NAME, A.LENGTH
FROM (
    SELECT FI2.ID, FI.FISH_TYPE, FI.LENGTH	
    FROM (
            SELECT FISH_TYPE, MAX(LENGTH) LENGTH
            FROM FISH_INFO
            GROUP BY FISH_TYPE ) FI, FISH_INFO FI2
    WHERE FI.FISH_TYPE = FI2.FISH_TYPE AND FI.LENGTH = FI2.LENGTH
    )A, FISH_NAME_INFO B
WHERE A.FISH_TYPE = B.FISH_TYPE

# GROUP BY
-- 조건에 맞는 사용자와 총 거래금액 조회하기
SELECT UGU.USER_ID, UGU.NICKNAME, UGB.TOTAL_SALES
FROM (
        SELECT WRITER_ID, SUM(PRICE) TOTAL_SALES
        FROM USED_GOODS_BOARD
        WHERE STATUS = 'DONE'
        GROUP BY WRITER_ID
        HAVING SUM(PRICE) >= 700000
    )UGB, USED_GOODS_USER UGU 
WHERE UGB.WRITER_ID = UGU.USER_ID
ORDER BY UGB.TOTAL_SALES

-- 저자 별 카테고리 별 매출액 집계하기
SELECT BB.AUTHOR_ID, A.AUTHOR_NAME, BB.CATEGORY, BB.TOTAL_SALES
FROM (
        SELECT B.AUTHOR_ID, B.CATEGORY, SUM(BS.SALES * B.PRICE) TOTAL_SALES
        FROM BOOK B INNER JOIN BOOK_SALES BS ON B.BOOK_ID = BS.BOOK_ID 
        WHERE DATE_FORMAT(BS.SALES_DATE,'%Y-%m') = '2022-01'
        GROUP BY B.AUTHOR_ID, B.CATEGORY
     ) BB, AUTHOR A
WHERE BB.AUTHOR_ID = A.AUTHOR_ID
ORDER BY BB.AUTHOR_ID, BB.CATEGORY DESC

-- 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기 ( ~~ LIKE '%값%')
SELECT CAR_TYPE, COUNT(*) CARS
FROM CAR_RENTAL_COMPANY_CAR
WHERE OPTIONS LIKE '%통풍시트%' OR OPTIONS LIKE '%열선시트%' OR OPTIONS LIKE '%가죽시트%'
GROUP BY CAR_TYPE
ORDER BY CAR_TYPE

-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기 (MONTH 함수, WINDOW함수 사용)
SELECT MONTH(START_DATE) MONTH, CAR_ID, COUNT(*) RECORDS
FROM (
    SELECT	car_id, start_date, COUNT(*) OVER(PARTITION BY CAR_ID) CNT
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE DATE_FORMAT(START_DATE,'%Y-%m') >= '2022-08' AND DATE_FORMAT(START_DATE,'%Y-%m') <= '2022-10'
    ) SUB
WHERE CNT>=5
GROUP BY MONTH, CAR_ID
ORDER BY MONTH, CAR_ID DESC

-- 성분으로 구분한 아이스크림 총 주문량
SELECT I.INGREDIENT_TYPE, SUM(F.TOTAL_ORDER) TOTAL_ORDER
FROM FIRST_HALF F JOIN ICECREAM_INFO I ON F.FLAVOR = I.FLAVOR
GROUP BY I.INGREDIENT_TYPE
ORDER BY TOTAL_ORDER

-- 즐겨찾기가 가장 많은 식당 정보 출력
SELECT FOOD_TYPE, REST_ID,REST_NAME,FAVORITES
FROM (
    SELECT FOOD_TYPE, REST_ID,REST_NAME,FAVORITES,
       MAX(FAVORITES) OVER(PARTITION BY FOOD_TYPE) MAX_FAV
    FROM REST_INFO
     ) SUB
WHERE FAVORITES = MAX_FAV
ORDER BY FOOD_TYPE DESC

-- 카테고리 별 도서 판매량 집계하기
SELECT CATEGORY, SUM(SALES) TOTAL_SALES
FROM BOOK B JOIN BOOK_SALES BS ON B.BOOK_ID = BS.BOOK_ID
WHERE DATE_FORMAT(SALES_DATE,'%Y-%m')='2022-01'
GROUP BY  CATEGORY
ORDER BY CATEGORY

-- 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기
SELECT CAR_ID,
        CASE
            WHEN CAR_ID IN (SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY WHERE START_DATE <= '2022-10-16' AND END_DATE >= '2022-10-16') THEN '대여중'
            ELSE '대여 가능'
        END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC

-- 진료과별 총 예약 횟수 출력하기
SELECT MCDP_CD, COUNT(*) '5월예약건수'
FROM APPOINTMENT 
WHERE DATE_FORMAT(APNT_YMD,'%Y-%m') = '2022-05'
GROUP BY MCDP_CD
ORDER BY 2,1

-- 식품분류별 가장 비싼 식품의 정보 조회하기
SELECT CATEGORY,PRICE MAX_PRICE,PRODUCT_NAME
FROM FOOD_PRODUCT
WHERE PRICE IN (
                SELECT MAX(PRICE)
                FROM FOOD_PRODUCT
                GROUP BY CATEGORY
                )
    AND CATEGORY IN ('과자', '국', '김치', '식용유')
ORDER BY PRICE DESC

-- 고양이와 개는 몇 마리 있을까
SELECT ANIMAL_TYPE, COUNT(*) count
FROM ANIMAL_INS
GROUP BY ANIMAL_TYPE
ORDER BY ANIMAL_TYPE

-- 동명 동물 수 찾기
SELECT NAME, COUNT(*) COUNT
FROM ANIMAL_INS
WHERE NAME IS NOT NULL
GROUP BY NAME
HAVING COUNT(*) >= 2
ORDER BY NAME

-- 년, 월, 성별 별 상품 구매 회원 수 구하기 (DISTINCT 사용)
-- 왜? 월별 통계를 계산할 때, 동일 유저가 2일에 걸쳐 구매한 경우도 1로 카운트 해야하기 때문
SELECT YEAR(SALES_DATE) YEAR ,MONTH(SALES_DATE) MONTH,GENDER, COUNT(DISTINCT UI.USER_ID) USERS
FROM USER_INFO UI JOIN ONLINE_SALE OS ON UI.USER_ID = OS.USER_ID
WHERE GENDER IS NOT NULL
GROUP BY YEAR(SALES_DATE), MONTH(SALES_DATE), GENDER
ORDER BY 1,2,3

-- 입양 시각 구하기(1)(HOUR 사용)
SELECT HOUR(DATETIME) HOUR, COUNT(*) COUNT
FROM ANIMAL_OUTS
WHERE HOUR(DATETIME) BETWEEN 9 AND 19
GROUP BY HOUR(DATETIME)
ORDER BY 1

-- 입양 시각 구하기(2)(WITH RECURSIVE 사용)
WITH RECURSIVE TEMP AS(
    SELECT 0 AS HOUR
    UNION ALL
    SELECT HOUR + 1 FROM TEMP
    WHERE HOUR < 23
)

SELECT T.HOUR, COUNT(HOUR(AO.DATETIME)) COUNT -- COUNT(*) 이렇게 하면 0이 아닌 1로 나와서 안됨.
FROM TEMP T LEFT JOIN ANIMAL_OUTS AO ON T.HOUR = HOUR(AO.DATETIME)
GROUP BY T.HOUR
ORDER BY 1

-- 가격대 별 상품 개수 구하기
SELECT CASE
            WHEN PRICE BETWEEN 10000 AND 19999 THEN 10000
            WHEN PRICE BETWEEN 20000 AND 29999 THEN 20000
            WHEN PRICE BETWEEN 30000 AND 39999 THEN 30000
            WHEN PRICE BETWEEN 40000 AND 49999 THEN 40000
            WHEN PRICE BETWEEN 50000 AND 59999 THEN 50000
            WHEN PRICE BETWEEN 60000 AND 69999 THEN 60000
            WHEN PRICE BETWEEN 70000 AND 79999 THEN 70000
            WHEN PRICE BETWEEN 80000 AND 89999 THEN 80000
            ELSE 0
        END PRICE_GROUP,
        COUNT(*)   
FROM PRODUCT
GROUP BY 1
ORDER BY 1

-- 조건에 맞는 사원 정보 조회하기
SELECT SCORE,A.EMP_NO,EMP_NAME,POSITION,EMAIL
FROM (
        SELECT EMP_NO,
                SUM(SCORE) OVER(PARTITION BY EMP_NO) SCORE
        FROM HR_GRADE
        WHERE YEAR = '2022'
    ) A, HR_EMPLOYEES B
WHERE A.EMP_NO = B.EMP_NO
ORDER BY SCORE DESC LIMIT 1

-- 연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기 (문제 이상 - 평균필요)
SELECT HE.EMP_NO, EMP_NAME, 
        CASE
             WHEN AVG(SCORE) >= 96 THEN 'S'
             WHEN AVG(SCORE) >= 90 THEN 'A'
             WHEN AVG(SCORE) >= 80 THEN 'B'
             ELSE 'C' END AS GRADE,
       SAL * CASE
                WHEN AVG(SCORE) >= 96 THEN 0.2
                WHEN AVG(SCORE) >= 90 THEN 0.15
                WHEN AVG(SCORE) >= 80 THEN 0.1
                ELSE 0 END AS BONUS
FROM HR_GRADE HG, HR_EMPLOYEES HE
WHERE HG.EMP_NO = HE.EMP_NO
GROUP BY EMP_NO
ORDER BY 1

-- 부서별 평균 연봉 조회하기
SELECT HD.DEPT_ID, DEPT_NAME_EN, ROUND(AVG(SAL)) AVG_SAL
FROM HR_DEPARTMENT HD JOIN HR_EMPLOYEES HE ON HD.DEPT_ID = HE.DEPT_ID
GROUP BY HD.DEPT_ID
ORDER BY AVG_SAL DESC

-- 물고기 종류 별 잡은 수 구하기
SELECT COUNT(*) FISH_COUNT, FISH_NAME
FROM FISH_INFO FI JOIN FISH_NAME_INFO FNI ON FI.FISH_TYPE = FNI.FISH_TYPE
GROUP BY FISH_NAME
ORDER BY 1 DESC

-- 월별 잡은 물고기 수 구하기
SELECT COUNT(*) FISH_COUNT, MONTH(TIME) MONTH
FROM FISH_INFO 
GROUP BY MONTH(TIME)
ORDER BY 2

-- 노선별 평균 역 사이 거리 조회하기
SELECT ROUTE, CONCAT(ROUND(SUM(D_BETWEEN_DIST),1),'km') TOTAL_DISTANCE, CONCAT(ROUND(AVG(D_BETWEEN_DIST),2),'km') AVERAGE_DISTANCE	
FROM SUBWAY_DISTANCE 
GROUP BY ROUTE
ORDER BY 2 DESC

-- 특정 조건을 만족하는 물고기별 수와 최대 길이 구하기
SELECT COUNT(*) FISH_COUNT, MAX(LENGTH)	MAX_LENGTH,	FISH_TYPE
FROM FISH_INFO
GROUP BY FISH_TYPE
HAVING AVG(IFNULL(LENGTH, 10)) >= 33
ORDER BY 3

-- 언어별 개발자 분류하기
SELECT GRADE, ID, EMAIL
FROM(
    SELECT 
        CASE
            WHEN SKILL_CODE & (SELECT sum(CODE) FROM SKILLCODES WHERE CATEGORY = "Front End") AND SKILL_CODE & (SELECT sum(CODE) FROM SKILLCODES WHERE NAME = "Python") THEN 'A'
            WHEN SKILL_CODE & (SELECT sum(CODE)
                                FROM SKILLCODES
                                WHERE NAME = 'C#') THEN 'B'
            WHEN SKILL_CODE & (SELECT sum(CODE)
                                FROM SKILLCODES
                                WHERE CATEGORY = "Front End") THEN 'C'
            END GRADE, ID, EMAIL
    FROM DEVELOPERS
    ) A
WHERE GRADE IS NOT NULL
ORDER BY 1, 2

# IS NULL
-- 경기도에 위치한 식품창고 목록 출력하기
SELECT WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, IFNULL(FREEZER_YN,'N') FREEZER_YN
FROM FOOD_WAREHOUSE
WHERE LEFT(ADDRESS,3) = '경기도'
ORDER BY 1

-- 이름이 없는 동물의 아이디
SELECT ANIMAL_ID
FROM ANIMAL_INS
WHERE NAME IS NULL
ORDER BY 1

-- 이름이 있는 동물의 아이디
SELECT ANIMAL_ID
FROM ANIMAL_INS
WHERE NAME IS NOT NULL
ORDER BY 1

-- NULL 처리하기
SELECT ANIMAL_TYPE, IFNULL(NAME,'No name') NAME, SEX_UPON_INTAKE
FROM ANIMAL_INS

-- 나이 정보가 없는 회원 수 구하기
SELECT COUNT(*) USERS
FROM USER_INFO
WHERE AGE IS NULL

-- ROOT 아이템 구하기
SELECT ITEM_ID,ITEM_NAME	
FROM ITEM_INFO
WHERE ITEM_ID IN (
                    SELECT ITEM_ID
                    FROM ITEM_TREE 
                    WHERE PARENT_ITEM_ID IS NULL
                )
ORDER BY 1

-- 업그레이드 할 수 없는 아이템 구하기
SELECT ITEM_ID, ITEM_NAME, RARITY
FROM ITEM_INFO
WHERE ITEM_ID NOT IN (SELECT DISTINCT PARENT_ITEM_ID
                    FROM ITEM_TREE
                    WHERE PARENT_ITEM_ID IS NOT NULL
                    )
ORDER BY 1 DESC

-- 잡은 물고기의 평균 길이 구하기
SELECT ROUND(AVG(IFNULL(LENGTH,10)),2) AVERAGE_LENGTH
FROM FISH_INFO 